/*
 * eScoots_Brain_v1
 * Arduino Code for HighJinx's eScooter
 * used on Adafruit M0/M4/Huzzah32 Feathers
 * and FeatherOLED Wing.
*/

#if ARDUINO_ARCH_ESP32
#include <Arduino.h>
#include <analogWrite.h>
#endif

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
Adafruit_SSD1306 display(128, 32, &Wire);

// OLED FeatherWing buttons map to different pins depending on board:
#if defined(ESP32)
  #define BUTTON_A 15
  #define BUTTON_B 32
  #define BUTTON_C 14
#else // 32u4, M0, M4, nrf52840 and 328p
  #define BUTTON_A  9
  #define BUTTON_B  6
  #define BUTTON_C  5
#endif

boolean HAS_OLED = false;

const uint8_t logo_bmp[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x06, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0e, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0f, 0x00,
  0x00, 0x00, 0x30, 0x00, 0xc0, 0x60, 0x18, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x20, 0x30, 0x1f, 0x00,
  0x00, 0x03, 0xf0, 0x00, 0xe0, 0x70, 0x18, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x30, 0x70, 0x3f, 0x00,
  0x00, 0x0f, 0xf0, 0x10, 0xe0, 0x70, 0x3c, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x30, 0x70, 0x3f, 0x00,
  0x00, 0x1f, 0xe0, 0x30, 0x70, 0x38, 0x3c, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x30, 0x60, 0x3f, 0x00,
  0x00, 0x3f, 0xa0, 0x30, 0xf0, 0x79, 0xff, 0x0f, 0xe8, 0x00, 0x00, 0x00, 0x38, 0xe0, 0x37, 0x00,
  0x00, 0x78, 0x00, 0x71, 0xf8, 0xfd, 0xff, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x38, 0xe0, 0x27, 0x00,
  0x00, 0x78, 0x01, 0xf1, 0xf8, 0xfd, 0xfe, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x38, 0xe0, 0x27, 0x00,
  0x00, 0x78, 0x03, 0xf3, 0xd9, 0xec, 0x7c, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xe0, 0x07, 0x00,
  0x00, 0x7c, 0x03, 0xf3, 0x9d, 0xce, 0x3c, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xc0, 0x07, 0x00,
  0x00, 0x3f, 0xc7, 0x83, 0x9d, 0xce, 0x1c, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x1e, 0xc0, 0x07, 0x00,
  0x00, 0x0f, 0xe7, 0x83, 0x1d, 0x8e, 0x1c, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x07, 0x00,
  0x00, 0x07, 0xe7, 0x07, 0x1f, 0x8e, 0x1c, 0x01, 0xf8, 0x07, 0xff, 0x80, 0x0f, 0xc0, 0x07, 0x00,
  0x00, 0x00, 0xfe, 0x07, 0x0f, 0x86, 0x1c, 0x00, 0x3c, 0x07, 0xff, 0xe0, 0x0f, 0xc0, 0x07, 0x00,
  0x00, 0x00, 0x7e, 0x07, 0x0f, 0x86, 0x1c, 0x00, 0x1e, 0x03, 0xff, 0xe0, 0x0f, 0x80, 0x07, 0x00,
  0x00, 0x00, 0x7f, 0x07, 0x0f, 0x86, 0x0e, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x07, 0x80, 0x07, 0x00,
  0x00, 0x00, 0x7f, 0x07, 0x1f, 0x8e, 0x0e, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x07, 0x80, 0x07, 0x00,
  0x00, 0x00, 0xf3, 0x87, 0x1f, 0x8e, 0x0f, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x03, 0x80, 0x07, 0x00,
  0x00, 0x01, 0xf3, 0xc3, 0x1d, 0x8e, 0x07, 0x80, 0x7c, 0x00, 0x00, 0x00, 0x03, 0x80, 0x07, 0x00,
  0x00, 0x07, 0xe1, 0xf3, 0x99, 0xcc, 0x03, 0xc1, 0xf8, 0x00, 0x00, 0x00, 0x03, 0x80, 0x07, 0x00,
  0x00, 0x0f, 0xc0, 0xfb, 0xf9, 0xfc, 0x03, 0xe3, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x80, 0x0f, 0x00,
  0x00, 0x3f, 0x80, 0x79, 0xf8, 0xfc, 0x01, 0xef, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x0f, 0x00,
  0x00, 0x7e, 0x00, 0x19, 0xf0, 0xf8, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00,
  0x00, 0x7c, 0x00, 0x09, 0xf0, 0xf8, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
  0x00, 0x30, 0x00, 0x0c, 0x20, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00,
  0x00, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00
};


int throttle_input, throttle_mapped;
float mapped_dac;

void setup() {
  Serial.begin(115200); //start serial communication
  //while(!Serial){}

  initOLED(0);
  
  analogReadResolution(12); //set the ADC resolution to 12 bits, default is 10
  
  #if ARDUINO_ARCH_ESP32
  analogWriteResolution(10,A0); //set the Arduino DAC for 10 bits of resolution (max)
  #else
  analogWriteResolution(10); //set the Arduino DAC for 10 bits of resolution (max)
  #endif
  
  //Get user entered voltage, convert to DAC value, output DAC value
  analogWrite(A0,setDAC(0));
  showSplash(1000);
 
}

void loop(){
  //Serial.println();
  Serial.print("Measured throttle value is : ");
  throttle_input = analogRead(A1);
  #if ARDUINO_ARCH_ESP32
  throttle_mapped = map(throttle_input, 880, 2990, 0, 4095);
  #else
  throttle_mapped = map(throttle_input, 1085, 3210, 0, 4095);
  #endif
  if (throttle_mapped < 0) {throttle_mapped = 0; }
  
  mapped_dac = convertToVolt(throttle_mapped);
  
//  if (mapped_dac < 0.00) { mapped_dac = 0.00; }
//  if (mapped_dac > 3.305) { mapped_dac = 3.303; }

  mapped_dac = constrain(mapped_dac, 0.00, 3.303);
  
  //Serial.println(mapped_dac); //Read value at ADC pin A1 and print it
  analogWrite(A0,setDAC(mapped_dac));
  Serial.print(throttle_input); //Read value at ADC pin A1 and print it
  Serial.print(", Mapped throttle value is : ");
  Serial.print(throttle_mapped);
  Serial.print(", Mapped throttle voltage is : ");
  Serial.println(setDAC(mapped_dac));

}

void initOLED(int timeDelay){
  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C for 128x32
    Serial.println(F("SSD1306 allocation failed"));
    //for(;;); // Don't proceed, loop forever
  } else {
    HAS_OLED = true;
    // Show initial display buffer contents on the screen --
    // the library initializes this with an Adafruit splash screen.
    display.clearDisplay();
    display.display();
    delay(timeDelay); // Pause
  }
}

void showSplash(int dly) {
  display.clearDisplay();
  display.drawBitmap(
    (display.width()  - 128 ) / 2,
    (display.height() - 32) / 2,
    logo_bmp, 128, 32, 1);
  display.display();
  delay(dly);
  clearOLED();
}

void clearOLED(){
  if(HAS_OLED) {
    display.clearDisplay();
    display.display();
  }
}

//this function converts a user entered voltage value into a 10 bit DAC value 
int setDAC(float volt) {
 //formula for calculating DAC output voltage Vdac = (dVal / 1023)*3.3V
 return (int)((volt*1023)/3.3);
}

//This function takes and ADC integer value (0 to 4095) and turns it into a voltage level. The input is the measured 12 bit ADC value.
float convertToVolt(int aVAL) {
 return (((float)aVAL/4095)*3.3); //formula to convert ADC value to voltage reading
}
